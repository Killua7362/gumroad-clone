import { useMutation } from "@tanstack/react-query"
import { queryClient } from "@/app/RootPage"
import { hideToastState, modalBaseActive } from "@/atoms/states"
import { useSetRecoilState } from "recoil"
import { useNavigate } from "react-router"
import React from "react"

const productDeleter = ({ id }: { id: string }) => {
	const setModalActive = useSetRecoilState(modalBaseActive)

	const { mutate, isPending } = useMutation({
		mutationFn: () => fetch(`${window.location.origin}/api/products/${id}`, {
			method: 'DELETE',
			credentials: 'include',
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return {}
		}),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['allProducts', id!], exact: true })
			return queryClient.invalidateQueries({ queryKey: ['allProducts'], exact: true })
		},
		onError: (err) => {
			console.log(err)
		},
		onSettled: () => {
			setModalActive({
				active: false,
				type: ""
			})
		}
	})

	return { mutate, isPending } as { mutate: () => void, isPending: boolean }
}

const productCreater = () => {
	const setModalActive = useSetRecoilState(modalBaseActive)

	const { mutate, isPending } = useMutation({
		mutationFn: (payload: ProductType) => fetch(`${window.location.origin}/api/products`, {
			method: 'POST',
			credentials: 'include',
			body: JSON.stringify(payload),
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: () => {
			return queryClient.invalidateQueries({ queryKey: ['allProducts'] })
		},
		onError: (err) => { },
		onSettled: () => {
			setModalActive({
				active: false,
				type: ""
			})
		}
	})

	return { mutate, isPending } as { mutate: () => void, isPending: boolean }
}

const getLoginStatus = () => {
	const navigate = useNavigate()

	const { mutate, isPending } = useMutation({
		mutationFn: () => fetch(`${window.location.origin}/api/sessions/logout`, {
			method: 'DELETE',
			credentials: 'include',
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: () => {
			navigate('/signin')
			return queryClient.clear()
		},
		onError: (err) => {

		}
	})

	return { mutate, isPending } as { mutate: () => void, isPending: boolean }
}

const collabApprover = () => {
	const { mutate, isPending } = useMutation({
		mutationFn: (key: string) => fetch(`${window.location.origin}/api/collabs/${key}/approve`, {
			method: 'POST',
			credentials: 'include',
			body: JSON.stringify({}),
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: () => {
			return queryClient.invalidateQueries({ queryKey: ['collabProducts'] })
		},
		onError: (err) => { },
	})

	return { mutate, isPending } as { mutate: () => void, isPending: boolean }
}

const productEditor = ({ id, setEditProductState }: { id: string, setEditProductState: React.Dispatch<React.SetStateAction<ProductType>> }) => {
	const setToastRender = useSetRecoilState(hideToastState)


	const { mutate, isPending } = useMutation({
		mutationFn: (payload: ProductType) => fetch(`${window.location.origin}/api/products/${id}`, {
			method: 'PATCH',
			credentials: 'include',
			body: JSON.stringify(payload),
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: (data, payload) => {
			setEditProductState(prev => {
				return { ...prev, ...data.data.attributes! }
			})

			setToastRender({
				active: false,
				message: 'Product updated successfully'
			})
			queryClient.invalidateQueries({ queryKey: ['allProducts', id!], exact: true })
			return queryClient.invalidateQueries({ queryKey: ['allProducts'], exact: true })
		},
		onError: (err) => {
			setToastRender({
				active: false,
				message: err.message
			})
		}
	})

	const { mutate: collabChecker, isPending: productIsPending } = useMutation({
		mutationFn: (payload: ProductType) => fetch(`${window.location.origin}/api/collabs/validate_user`, {
			method: 'POST',
			credentials: 'include',
			body: JSON.stringify({ collabs: [...payload.collabs!].map(e => e.email) }),
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: (data, payload) => {
			if (data.valid) {
				mutate({ ...payload })
			} else {
				(data.data || []).map((e: string, index: number) => {
					e &&
						setError(`collabs.${index}.email`, {
							type: `collabs.${index}.email`,
							message: e
						})
				})
			}
		},
		onError: (error) => { }
	})

	return { collabChecker, productIsPending } as { collabChecker: () => void, productIsPending: boolean }
}

const productLiveToggle = () => {
	const setModalActive = useSetRecoilState(modalBaseActive)
	const setToastRender = useSetRecoilState(hideToastState)

	const { mutate, isPending } = useMutation({
		mutationFn: (payload: { key: string, live: boolean }) => fetch(`${window.location.origin}/api/products/${payload.key}`, {
			method: 'PATCH',
			credentials: 'include',
			body: JSON.stringify({ live: payload.live }),
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: () => {
			setModalActive({
				active: false,
				type: ""
			})
			return queryClient.invalidateQueries({ queryKey: ['allProducts'] })
		},
		onError: (err) => {
			setToastRender({
				active: false,
				message: err.message
			})
		}
	})

	return { mutate, isPending } as { mutate: () => void, isPending: boolean }
}

const setLoginStatus = ({ setCustomError }: { setCustomError: React.Dispatch<React.SetStateAction<string>> }) => {
	const navigate = useNavigate()

	const { mutate, isPending } = useMutation({
		mutationFn: (payload: signInSchemaType) => fetch(`${window.location.origin}/api/sessions`, {
			method: 'POST',
			credentials: 'include',
			body: JSON.stringify(payload),
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: () => {
			navigate('/')
			return queryClient.clear()
		},
		onError: (err) => {
			setCustomError(err.message)
		}
	})


}

const setSignUp = ({ setCustomError }: { setCustomError: React.Dispatch<React.SetStateAction<string>> }) => {
	const navigate = useNavigate()

	const { mutate, isPending } = useMutation({
		mutationFn: (payload: signUpSchemaType) => fetch(`${window.location.origin}/api/registrations`, {
			method: 'POST',
			credentials: 'include',
			body: JSON.stringify(payload),
			headers: { 'Content-type': 'application/json' },
		}).then(async (res) => {
			if (!res.ok) {
				const errorMessage: string = await res.json().then(data => data.error)
				return Promise.reject(new Error(errorMessage))
			}
			return res.json()
		}),
		onSuccess: () => {
			navigate('/signin')
		},
		onError: (err) => {
			setCustomError(err.message)
		},
	})
}
